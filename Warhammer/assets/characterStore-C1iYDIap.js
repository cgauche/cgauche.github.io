import{J as i,O as n,N as g,M as r,K as a,ag as N,ah as b,ai as A,R as u,Q as d,aj as k,V as f,ak as T,U as h,al as D,W as P,am as U,an as v,ao as C,ap as q}from"./index-DPNhxiUx.js";import{g as w,t as j}from"./createCharacter-Bh61okBK.js";import"./PDFButton-DossJXaQ.js";const L=i({gold:r().int().min(0),silver:r().int().min(0),bronze:r().int().min(0)}),x=i({name:a().min(1),spec:a(),advances:r().int().min(0).max(100),characteristic:a().optional(),type:f(["base","avancÃ©e"]).optional()}),S=i({name:a().min(1),spec:a(),ranks:r().int().min(1).max(10),type:f(["choice","random"]).optional(),options:n(a()).optional(),randomCount:r().int().min(1).optional()}),O=i({name:a().min(1),quantity:r().int().min(0),randomQuantity:a().optional(),data:T.optional()}),_=i({characteristic:a().min(1),modifier:r().int().min(-10).max(10)}),I=i({id:a().min(1),data:k,skills:n(x),talents:n(S)}),M=i({id:a().regex(/^.+\|[1-4]$/),career:a().min(1),level:u([d(1),d(2),d(3),d(4)]),data:A,class:a().min(1),status:b,characteristics:n(a()),skills:n(x),talents:n(S),trappings:n(O)}),z=i({id:a().min(1),data:N,modifiers:n(_),talent:S.optional()}),H=i({id:a().min(1).max(50),base:r().int().min(0).max(150),star:r().int().min(-10).max(10),talent:r().int().min(0).max(50),advance:r().int().min(0).max(100),breakdown:i({specie:r().int().min(0).max(100),roll:r().int().min(0).max(20),careerAdvance:r().int().min(0).max(100)}).optional()}),Q=i({label:a().min(1),id:a().min(1),specs:n(a()).optional()}),E=i({id:a().min(1),spec:a(),advance:r().int().min(0).max(100),tmpadvance:r().int().min(0).max(100),origins:n(a()),inCareer:h(),choices:n(Q).optional(),specs:n(a()).optional(),randomCount:r().int().min(1).optional()}),V=E.extend({reduced:r().int().optional()}),X=E,B=i({id:a().min(1),source:a().min(1),free:h()}),F=i({id:a().min(1),quantity:r().int().min(0).max(1e3),equipped:h(),origin:a().min(1)}),G=i({type:a().min(1),value:u([a(),r()]),random:h()}),J=i({type:a().min(1),label:a().min(1),from:r().int().min(0),to:r().int().min(0),cost:r().int(),timestamp:a().datetime()}),K=i({max:r().int().min(0).max(1e5),used:r().int().min(0).max(1e5),tmp_used:r().int().min(0).max(1e5),totalUsed:r().int().min(0).max(1e5),available:r().int().min(0).max(1e5),log:n(J)}),R=i({id:a().regex(/^.+\|[1-4]$/),career:a().min(1),levels:n(r().int().min(1).max(4)),startedAt:a().datetime(),endedAt:u([a().datetime(),D()]).optional()}),p=i({saveName:a().regex(/^_[a-z0-9]{10}$/).optional(),createdAt:a().datetime().optional(),updatedAt:a().datetime().optional(),version:a().regex(/^\d+\.\d+$/),specie:I.nullable(),careerLevel:M.nullable(),star:z.nullable(),god:a().nullable(),magicDomain:n(a()).nullable(),characteristics:n(H).max(20),skills:n(V),talents:n(X),spells:n(B),trappings:n(F),wallet:L.nullable(),details:n(G),xp:K,careerHistory:n(R),specieSeed:r().int().min(0).optional(),specieState:r().int().min(-2).max(1).optional(),careerSeed:r().int().min(0).optional(),careerState:r().int().min(0).max(3).optional(),starSeed:r().int().min(0).optional(),starState:r().int().min(-2).max(1).optional(),characteristicSeeds:g(a(),r().int().min(0)).optional(),imposedCharacteristics:g(a(),r().int()).optional(),imposedTalents:n(a()).optional()}),$=P((o,m)=>({current:null,characters:[],loadingState:"idle",loadingError:null,loadCharacter:async t=>{o({loadingState:"loading",loadingError:null});try{const e=await v("characters",t);if(!e)throw new Error(`Character ${t} not found`);const c=p.safeParse(e);c.success||console.warn(`Character ${t} validation warnings:`,c.error.issues),o({current:e,loadingState:"loaded"})}catch(e){o({loadingState:"error",loadingError:e instanceof Error?e.message:"Unknown error"})}},saveCharacter:async()=>{const{current:t}=m();if(!t)throw console.error("[characterStore] saveCharacter: No character to save"),new Error("No character to save");console.log("[characterStore] saveCharacter: Starting save...",{saveName:t.saveName}),o({loadingState:"loading",loadingError:null});try{let e=t;if(e.saveName||(e={...e,saveName:w()},console.log("[characterStore] saveCharacter: Generated saveName:",e.saveName)),e=j(e),!e.saveName)throw new Error("Character saveName is required for saving");const c=p.safeParse(e);if(!c.success){const s=c.error.issues.map(l=>`${l.path.join(".")}: ${l.message}`).join(", ");throw console.error("[characterStore] saveCharacter: Validation failed:",c.error.issues),new Error(`Character validation failed: ${s}`)}console.log("[characterStore] saveCharacter: Saving to IndexedDB...",{saveName:e.saveName}),await C("characters",e.saveName,e),console.log("[characterStore] saveCharacter: Save successful"),o({current:e,loadingState:"loaded"}),await m().loadAllCharacters()}catch(e){throw console.error("[characterStore] saveCharacter: Error:",e),o({loadingState:"error",loadingError:e instanceof Error?e.message:"Unknown error"}),e}},deleteCharacter:async t=>{o({loadingState:"loading",loadingError:null});try{await q("characters",t);const{current:e}=m();e?.saveName===t&&o({current:null}),await m().loadAllCharacters(),o({loadingState:"loaded"})}catch(e){o({loadingState:"error",loadingError:e instanceof Error?e.message:"Unknown error"})}},duplicateCharacter:async t=>{o({loadingState:"loading",loadingError:null});try{const e=await v("characters",t);if(!e)throw new Error(`Character ${t} not found`);const c=new Date().toISOString(),s={...e,saveName:w(),createdAt:c,updatedAt:c},l=s.details?.find(y=>y.type==="Nom");if(l&&(l.value=`${l.value} (Copie)`),!s.saveName)throw new Error("Failed to generate saveName for duplicate");await C("characters",s.saveName,s),await m().loadAllCharacters(),o({loadingState:"loaded"})}catch(e){o({loadingState:"error",loadingError:e instanceof Error?e.message:"Unknown error"})}},loadAllCharacters:async()=>{o({loadingState:"loading",loadingError:null});try{const t=await U("characters");t.forEach(e=>{const c=p.safeParse(e);c.success||console.warn(`Character ${e.saveName||"unknown"} validation warnings:`,c.error.issues)}),t.sort((e,c)=>{const s=e.updatedAt?new Date(e.updatedAt).getTime():0;return(c.updatedAt?new Date(c.updatedAt).getTime():0)-s}),o({characters:t,loadingState:"loaded"})}catch(t){o({loadingState:"error",loadingError:t instanceof Error?t.message:"Unknown error"})}},updateCharacter:t=>{const{current:e}=m();if(!e)return;const c={...e,...t,updatedAt:new Date().toISOString()};o({current:c})},setCurrent:t=>{o({current:t})}}));export{$ as u};
